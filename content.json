[{"title":"MyBaits的使用","date":"2022-01-14T01:11:06.000Z","path":"2022/01/14/MyBaits的使用/","text":"MyBatisMyBatis的模糊查询 方式一 1`field_name` like concat(&#x27;%&#x27;, #&#123;value&#125;, &#x27;%&#x27;) 栗子 1`group_name` like concat(&#x27;%&#x27;,#&#123;groupName&#125;, &#x27;%&#x27;) 方式二 1`field_name` like concat(&#x27;%&#x27;, $&#123;value&#125;, &#x27;%&#x27;) 栗子 1`group_name` like concat(&#x27;%&#x27;,$&#123;groupName&#125;, &#x27;%&#x27;) 总结： #{ }是预编译处理，MyBatis在处理#{ }时，它会将sql中的#{ }替换为？，然后调用PreparedStatement的set方法来赋值，传入字符串后，会在值两边加上单引号，使用占位符的方式提高效率，可以防止sql注入。 ${}:表示拼接sql串，将接收到参数的内容不加任何修饰拼接在sql中，可能引发sql注入。","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://zhoufengbin.github.io/tags/MyBatis/"}]},{"title":"Java集合之List","date":"2022-01-13T06:58:56.000Z","path":"2022/01/13/Java集合之List/","text":"1、List集合1.1 List集合的排序 内部类方式—Comparator 123456789101112// 升序排序Collections.sort(list, new Comparator&lt;test&gt;() &#123; @Override public int compare(test o1, test o2) &#123; return o1.getCmonth().compareTo(o2.getCmonth()); &#125; // 降序排序Collections.sort(list, new Comparator&lt;test&gt;() &#123; @Override public int compare(test o1, test o2) &#123; return o1.getCmonth().compareTo(o2.getCmonth()); &#125; 实现比较类—Comparable 123456789101112131415161718192021@Datapublic class Test implements Comparable&lt;Test&gt;&#123; private String name; private Integer age; // 升序排序 @Override public int compareTo(Test o) &#123; return this.age.compareTo(o.getAge()); &#125; // 降序排序 @Override public int compareTo(Test o) &#123; return this.age.compareTo(o.getAge()); &#125;&#125;//需要排序的集合排序 List&lt;Test&gt;Collections.sort(list); Stream流方式 1234567// stream流方式-降序排序(逆序排序)list = list.stream().sorted(Comparator.comparing(test::getAge) .reversed()) .collect(Collectors.toList());//stream流方式-升序排序list =list.stream().sorted(Comparator.comparing(test::getAge)) .collect(Collectors.toList());","tags":[{"name":"List","slug":"List","permalink":"https://zhoufengbin.github.io/tags/List/"}]},{"title":"Docker的使用","date":"2022-01-12T08:13:23.000Z","path":"2022/01/12/Docker的使用/","text":"启动运行MySQL镜像1docker run -p 3306:3306 --name MySQL8.0 -e MYSQL_ROOT_PASSWORD=041225 -d mysql:8.0","tags":[{"name":"Docker","slug":"Docker","permalink":"https://zhoufengbin.github.io/tags/Docker/"}]},{"title":"数据库常用SQL操作","date":"2022-01-12T07:04:53.000Z","path":"2022/01/12/数据库常用SQL操作/","text":"一、SQLCURRENT_TIMESTAMP 字段属性 DEFAULT CURRENT_TIMESTAMP 表示当插入数据的时候，该字段默认值为当前时间 ON UPDATE CURRENT_TIMESTAMP 表示每次更新这条数据的时候，该字段都会更新成当前时间 栗子 12345CREATE TABLE `test` ( `text` varchar(255) DEFAULT &#x27;&#x27; COMMENT &#x27;内容&#x27;, `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;, `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;更新时间&#x27;) ENGINE=InnoDB DEFAULT CHARSET=utf8; SQL 创建/修改唯一索引 创建 1UNIQUE [INDEX | KEY] [&lt;索引名&gt;] [&lt;索引类型&gt;] (&lt;列名&gt;,…) 栗子 1UNIQUE KEY `unique_index`(`group_id`, `company_id`, `business_id`) 注意事项：在创建唯一索引时，一定要保证索引的唯一性。如上面栗子的索引字段，保存数据时是重复的，此时索引创建会报错。 修改 12ALTER TABLE `TableName` DROP INDEX `INDEX_NAME`;ALTER TABLE `TableName` ADD UNIQUE INDEX_NAME(`COLUMN`); 栗子 12ALTER TABLE follow_heart_store_sales_target_collect DROP INDEX `unique_index`ALTER TABLE follow_heart_store_sales_target_collect ADD UNIQUE KEY `unique_index`(`cdate`,`group_id`, `company_id`, `business_id`)","tags":[{"name":"SQL","slug":"SQL","permalink":"https://zhoufengbin.github.io/tags/SQL/"}]},{"title":"多线程","date":"2022-01-01T03:59:31.000Z","path":"2022/01/01/多线程/","text":"1. 多线程简介","tags":[{"name":"多线程","slug":"多线程","permalink":"https://zhoufengbin.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"Java常用API","date":"2021-12-31T16:08:39.000Z","path":"2022/01/01/Java常用API/","text":"1. String常用方法1.1 截取功能1","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://zhoufengbin.github.io/tags/Java%E5%9F%BA%E7%A1%80/"}]}]