[{"title":"大数据之Hadoop","date":"2022-06-25T07:26:35.000Z","path":"2022/06/25/大数据之Hadoop/","text":"1. Hadoop介绍 狭义上Hadoop指的是Apache软件基金会的一款开源软件。 用java语言实现，开源的。允许用户使用简单的编程模型实现跨机器集群对海量数据进行分布式计算处理。 Hadoop核心组件 Hadoop HDFS （分布式文件存储系统）︰解决海量数据存储。 Hadoop YARN（集群资源管理和任务调度框架）︰解决资源任务调度。 Hadoop MapReduce (分布式计算框架）︰解决海量数据计算。是一个计算框架，没有集群的说法。 官网 http: // hadoop. apache.org/ 2. Hadoop特点 扩容能力（scalability） Hadoop是在可用的计算机集群间分配数据并完成计算任务的，这些集群可方便灵活的方式扩展到数以千计的节点。 成本低(Economical) Hadoop集群允许通过部署普通廉价的机器组成集群来处理大数据，以至于成本很低。看重的是集群整体能力。 效率高(efficiency) 通过并发数据，Hadoop可以在节点之间动态并行的移动数据，使得速度非常快。 可靠性(reliability) 能自动维护数据的多份复制，并且在任务失败后能自动地重新部署( redeploy )计算任务。所以Hadoop的按位存储和处理数据的能力值得人们信赖。 3. Hadoop集群整体概述 Hadoop集群包括两个集群：HDFS集群、YARN集群。 HDFS集群：主要负责分布式存储。有三个角色，分别为：主角色(NameNode，NN)，从角色(DataNode, DN)，主角色辅助角色(SecondaryNameNode, SNN）。 YARN集群：主要负责资源管理、调度。有两个角色，分别为: 主角色(ResourceManager，RM)，从角色(NodeManager, NM)。 两个集群逻辑上是分离的，物理上在一起的。 两个集群都是标准的主从架构集群。","tags":[{"name":"大数据","slug":"大数据","permalink":"https://zhoufengbin.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]},{"title":"Redis数据库","date":"2022-06-01T10:50:48.000Z","path":"2022/06/01/Redis数据库/","text":"1. Redis简介2. Redis安装3. Redis常用命令 select ： 选择数据库。如：select 0; select 15。 set : 设置键值。如：set key1 value1; set key2 value2。 keys * ： 查看当前库中所有的键值。 get key : 根据键获取对应的值。如：get key1; exists key ： 判断当前键是否存在，0 不存在；1 存在。 del key : 删除当前库中的键。 **type key : ** 查看key类型。 expire key : 设置键的过期时间。默认单位为秒。如： expire key1 10; ttl key : 查看键剩余的过期时间。-1 表示永不过期；-2表示已过期。 **dbsize : ** 查看当前库中的键的数量。 **flushdb : ** 清空当前库中所有的键。 **flushall : ** 清空所有的库中的数据。 4. Redis中常用的数据类型 字符串(String) 列表(List) 集合(Set) 哈希(Hash) 有序集合(ZSet) 4.1 String 字符串4.1.1 简介 String类型是Redis最基本的类型，存储的类型是二进制安全的，可以存储任意类型的数据，value的最大存储512M。 4.1.2 数据结构类型？ 4.2 List 列表4.2.1 简介 List 列表是最简单的字符串列表，插入是有序的，头部和尾部都可以添加元素。 4.2.1 数据结构？ 底层实现为双向链表，对两端的可操作性高，通过索引操作中间元素性能较差。 4.3 Set 集合4.3.1 简介 Set集合也是提供一个列表功能，无需的，可以自动去重，不允许存储重复的数据，在添加，删除，查找效率高，时间复杂度O(1)。 4.3 Hash 哈希4.3.1 简介4.3.2 数据结构 Hash类型的数据结构分为两种：zipList(压缩列表)，hashTable(哈希表)。当filed-value长度较短且数量较少时，使用zipList,否则使用hashTable。 4.4 ZSet有序集合4.4.1 简介 Redis的持久化 Redis的持久化方式分为两种分别为：RDB（Redis DataBase）和 AOF（Append Only File） RDB方式 在指定的时间间隔内将内存中的数据集快照写入硬盘保存。（每隔一段时间就保存数据） 执行方式 Redis主线程会fork一个子线程单独进行持久化工作，将数据写入到一个临时文件中（dump.rdb），待持久化操作完成后，临时文件将覆盖旧的持久化文件。 AOF","tags":[{"name":"redis","slug":"redis","permalink":"https://zhoufengbin.github.io/tags/redis/"}]},{"title":"排序算法","date":"2022-05-13T03:47:27.000Z","path":"2022/05/13/排序算法/","text":"","tags":[]},{"title":"easyExcel导出","date":"2022-04-28T03:46:22.000Z","path":"2022/04/28/easyExcel导出/","text":"1.easyEexcel策略模式导出数据1234567891011121314151617181920212223242526272829303132333435363738394041public interface ExportProcessor&lt;E, T&gt; &#123; /** * 获取并组装导出的数据 * * @param searchDTO 导出数据查询条件 * @return */ List&lt;T&gt; getExportData(E searchDTO); /** * 指定导出文件名称 * * @return */ String exportFileName(E searchDTO); /** * 指定导出文件sheet名称 * * @return */ String exportSheetName(E searchDTO); /** * 根据搜索条件字符串转为搜索对象DTO * * @param searchCondition * @return */ E getSearchDTO(String searchCondition); /** * 指定导出的模版类型 * * @return */ Class&lt;T&gt; getExportTemplateClass();&#125; 12345678910111213141516public abstract class BaseExportProcessor&lt;E, T&gt; implements ExportProcessor&lt;E, T&gt; &#123; @Autowired private ExportProcessorService exportProcessorService; public @PostConstruct void registerProcesser() &#123; exportProcessorService.register(getProcessorType().getModuleCode(), this); &#125; abstract protected ModuleType getProcessorType();&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788@Service@Slf4jpublic class ExportProcessorService &#123; final OssFileService ossFileService; /** * 文件导出处理器注册容器 */ private Map&lt;String, ExportProcessor&gt; exportProcessors = new HashMap&lt;&gt;(); public ExportProcessorService(OssFileService ossFileService) &#123; this.ossFileService = ossFileService; &#125; /** * 注册文件导出处理器 * * @param moduleType * @param processor */ public void register(String moduleType, BaseExportProcessor processor) &#123; ExportProcessor previousReleaseProcessor = exportProcessors.put(moduleType, processor); if (previousReleaseProcessor != null) &#123; throw new RuntimeException(&quot;注册器检测到相同的模块类型，请保证模块类型的唯一性。冲突的模块类型为:&quot; + moduleType); &#125; &#125; public &lt;E&gt; Map&lt;String, String&gt; export(String moduleCode, E searchDTO) &#123; Map&lt;String, String&gt; resultMap = new HashMap&lt;&gt;(); ExportProcessor exportProcessor = exportProcessors.get(moduleCode); ByteArrayOutputStream out = new ByteArrayOutputStream(); EasyExcel.write(out, exportProcessor.getExportTemplateClass())// .registerWriteHandler(new StoreDataInstCellWriteHandler()) //内容策略 .registerWriteHandler(new LongestMatchColumnWidthStyleStrategy()) .excelType(ExcelTypeEnum.XLS) .sheet(exportProcessor.exportSheetName(searchDTO)) .doWrite(Lists.newArrayList(exportProcessor.getExportData(searchDTO))); String fileName = exportProcessor.exportFileName(searchDTO); ossFileService.upload(out.toByteArray(), fileName); String url = ossFileService.download(fileName).getResponse().getUri(); resultMap.put(&quot;code&quot;, &quot;10000&quot;); resultMap.put(&quot;url&quot;, url); return resultMap; &#125; public &lt;E&gt; Map&lt;String, String&gt; exportForDynamicHead(String moduleCode, E searchDTO, Class head) &#123; Map&lt;String, String&gt; resultMap = new HashMap&lt;&gt;(); ExportProcessor exportProcessor = exportProcessors.get(moduleCode); ByteArrayOutputStream out = new ByteArrayOutputStream(); EasyExcel.write(out, exportProcessor.getExportTemplateClass()) .head(head)// .registerWriteHandler(new StoreDataInstCellWriteHandler()) //内容策略 .registerWriteHandler(new LongestMatchColumnWidthStyleStrategy()) .excelType(ExcelTypeEnum.XLS) .sheet(exportProcessor.exportSheetName(searchDTO)) .doWrite(Lists.newArrayList(exportProcessor.getExportData(searchDTO))); String fileName = exportProcessor.exportFileName(searchDTO); ossFileService.upload(out.toByteArray(), fileName); String url = ossFileService.download(fileName).getResponse().getUri(); resultMap.put(&quot;code&quot;, &quot;10000&quot;); resultMap.put(&quot;url&quot;, url); return resultMap; &#125; public &lt;E&gt; Map&lt;String, String&gt; exportForDynamicHead(String moduleCode, E searchDTO, List&lt;List&lt;String&gt;&gt; head) &#123; Map&lt;String, String&gt; resultMap = new HashMap&lt;&gt;(); ExportProcessor exportProcessor = exportProcessors.get(moduleCode); ByteArrayOutputStream out = new ByteArrayOutputStream(); EasyExcel.write(out, exportProcessor.getExportTemplateClass()) .head(head)// .registerWriteHandler(new StoreDataInstCellWriteHandler()) //内容策略 .registerWriteHandler(new LongestMatchColumnWidthStyleStrategy()) .excelType(ExcelTypeEnum.XLS) .sheet(exportProcessor.exportSheetName(searchDTO)) .doWrite(Lists.newArrayList(exportProcessor.getExportData(searchDTO))); String fileName = exportProcessor.exportFileName(searchDTO); ossFileService.upload(out.toByteArray(), fileName); String url = ossFileService.download(fileName).getResponse().getUri(); resultMap.put(&quot;code&quot;, &quot;10000&quot;); resultMap.put(&quot;url&quot;, url); return resultMap; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435public enum ModuleType &#123; NOT_PARTICIPATE_GOODS(&quot;not_participate_goods&quot;, 1, &quot;不参与调拨/退仓商品设置&quot;), SMART_ALLOCAT_MAIN_BILL(&quot;smart_allocat_main_bill&quot;, 1, &quot;智能统筹调拨系统-主单&quot;), SMART_ALLOCAT_DETAIL_BILL(&quot;smart_allocat_detail_bill&quot;, 1, &quot;智能统筹调拨系统-明细&quot;), FOLLOW_HEART_BUSINESS_INFO(&quot;follow_heart_business_info&quot;, 1, &quot;随心看商户门店基础信息&quot;); private String moduleCode; /** * 模块类型， 1为单sheet，2为多sheet */ private Integer moduleType; private String moduleName; ModuleType(String moduleCode, Integer moduleType, String moduleName) &#123; this.moduleCode = moduleCode; this.moduleType = moduleType; this.moduleName = moduleName; &#125; public String getModuleCode() &#123; return moduleCode; &#125; public Integer getModuleType() &#123; return moduleType; &#125; public String getModuleName() &#123; return moduleName; &#125;&#125; 2.使用方式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Slf4j@Componentpublic class BusinessInfoExportProcessor extends BaseExportProcessor&lt;BatchBusinessInfoReqDTO, BusinessInfoExportEntity&gt; &#123; private final BusinessInfoSourceService businessInfoSourceService; private final HydeeSelectService hydeeSelectService; public BusinessInfoExportProcessor(BusinessInfoSourceService businessInfoSourceService, HydeeSelectService hydeeSelectService) &#123; this.businessInfoSourceService = businessInfoSourceService; this.hydeeSelectService = hydeeSelectService; &#125; @Override protected ModuleType getProcessorType() &#123; return ModuleType.FOLLOW_HEART_BUSINESS_INFO; &#125; @Override public List&lt;BusinessInfoExportEntity&gt; getExportData(BatchBusinessInfoReqDTO searchDTO) &#123; List&lt;BusinessInfoRepoDTO&gt; businessInfosEntity = businessInfoSourceService.queryExportBusinessInfo(searchDTO); //查询集团下的企业信息 List&lt;CompanyInfo&gt; companyInfos = hydeeSelectService.queryTopTableCompanyInfoByGroupId(searchDTO.getGroupId()); //查询集团的片区信息 List&lt;RegionInfo&gt; regionInfos = hydeeSelectService.queryRegionInfoByGroupId(searchDTO.getGroupId()); //封装数据 return BusinessInfoExportEntity.convert(businessInfosEntity, companyInfos, regionInfos); &#125; @Override public String exportFileName(BatchBusinessInfoReqDTO searchDTO) &#123; return &quot;门店基础信息数据.xls&quot;; &#125; @Override public String exportSheetName(BatchBusinessInfoReqDTO searchDTO) &#123; return &quot;门店基础信息数据&quot;; &#125; @Override public BatchBusinessInfoReqDTO getSearchDTO(String searchCondition) &#123; return null; &#125; @Override public Class&lt;BusinessInfoExportEntity&gt; getExportTemplateClass() &#123; return BusinessInfoExportEntity.class; &#125;&#125;","tags":[{"name":"easyExcel","slug":"easyExcel","permalink":"https://zhoufengbin.github.io/tags/easyExcel/"}]},{"title":"AOP实现多数据源切换.md","date":"2022-04-28T02:09:42.000Z","path":"2022/04/28/AOP实现多数据源切换-md/","text":"1.实例数据源123456789101112131415161718192021222324252627datasource: business: url: jdbc:mysql://ip:3306/hydee_dc_business_test?allowMultiQueries=true&amp;serverTimezone=Asia/Shanghai&amp;useSSL=false&amp;allowPublicKeyRetrieval=true username: hydee_dc_business_test password: WIAozx0ak3Hk driver-class-name: com.mysql.cj.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource dw: url: jdbc:mysql://ip:9030/doris_hydee_dw?allowMultiQueries=true&amp;serverTimezone=Asia/Shanghai&amp;useSSL=false&amp;allowPublicKeyRetrieval=true username: dorisdb_select password: O&amp;pH32e&amp;^!DJS5vI driver-class-name: com.mysql.cj.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource seal: url: jdbc:mysql://ip:3306/hydee_bi_seal?allowMultiQueries=true&amp;serverTimezone=Asia/Shanghai&amp;useSSL=false&amp;allowPublicKeyRetrieval=true username: seal password: seal123456 driver-class-name: com.mysql.cj.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource druid: initial-size: 10 min-idle: 10 max-active: 50 max-wait: 60000 time-between-eviction-runs-millis: 60000 min-evictable-idle-time-millis: 300000 validation-query: SELECT 1 FROM DUAL 2.定义AOP注解123456@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface DataSource &#123; DataSourceEnum value() default DataSourceEnum.BUSSINESS;&#125; 1234567891011121314151617181920212223242526272829303132333435@Component@Slf4j@Aspect@Order(-1)public class DataSourceAspect &#123; @Around(value = &quot;@annotation(DataSource)&quot;) public Object doAround(ProceedingJoinPoint pjp) &#123; MethodSignature methodSignature = (MethodSignature) pjp.getSignature(); Method method = methodSignature.getMethod(); DataSource typeAnno = method.getAnnotation(DataSource.class); DataSourceEnum sourceEnum = typeAnno.value(); // 设置数据源标志，spring获取这些标志之后就会获取对象的数据源，其实就bean的实例名称 if (sourceEnum == DataSourceEnum.BUSSINESS) &#123; DataSourceContextHolder.setDbType(DataSourceEnum.BUSSINESS); &#125; else if (sourceEnum == DataSourceEnum.DW) &#123; DataSourceContextHolder.setDbType(DataSourceEnum.DW); &#125;else if (sourceEnum == DataSourceEnum.SEAL) &#123; DataSourceContextHolder.setDbType(DataSourceEnum.SEAL); &#125; Object result = null; try &#123; result = pjp.proceed(); &#125; catch (Throwable throwable) &#123; log.error(&quot;切换数据源发生异常&quot;,throwable); &#125; finally &#123; DataSourceContextHolder.clearDbType(); &#125; return result; &#125;&#125; 1234567891011121314151617181920212223public class DataSourceContextHolder &#123; private static final ThreadLocal&lt;String&gt; CONTEXT_HOLDER = new InheritableThreadLocal&lt;&gt;(); /** * 设置数据源 */ public static void setDbType(DataSourceEnum dbTypeEnum) &#123; CONTEXT_HOLDER.set(dbTypeEnum.getValue()); &#125; /** * 取得当前数据源 */ public static String getDbType() &#123; return CONTEXT_HOLDER.get(); &#125; /** * 清除上下文数据 */ public static void clearDbType() &#123; CONTEXT_HOLDER.remove(); &#125;&#125; 123456789import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;public class MultipleDataSource extends AbstractRoutingDataSource &#123; //取得当前使用哪个数据源 @Override protected Object determineCurrentLookupKey() &#123; return DataSourceContextHolder.getDbType(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182@EnableTransactionManagement@Configuration@MapperScan( basePackages = &#123;&quot;cn.hydee.datacenter.business.*.repo&quot;,&quot;cn.hydee.datacenter.business.*.mapper&quot;&#125;) //dao和mapper文件路径public class MyBatiesPlusConfiguration &#123; /* * 分页插件，自动识别数据库类型 * 多租户，请参考官网【插件扩展】 */ @Bean public PaginationInterceptor paginationInterceptor() &#123; // 开启 PageHelper 的支持 // paginationInterceptor.setL(true); return new PaginationInterceptor(); &#125; //定义db1 @Bean(name = &quot;business&quot;) @ConfigurationProperties(prefix = &quot;spring.datasource.business&quot;)//与配置文件中的层次结构相同 public DruidDataSource db1() &#123; return DruidDataSourceBuilder.create().build(); &#125; @Bean(name = &quot;dw&quot;) @ConfigurationProperties(prefix = &quot;spring.datasource.dw&quot; ) public DruidDataSource db2() &#123; return DruidDataSourceBuilder.create().build(); &#125; @Bean(name = &quot;seal&quot;) @ConfigurationProperties(prefix = &quot;spring.datasource.seal&quot; ) public DruidDataSource db3() &#123; return DruidDataSourceBuilder.create().build(); &#125;// @Bean(name = &quot;h3&quot;)// @ConfigurationProperties(prefix = &quot;spring.datasource.h3&quot; )// public DruidDataSource db4() &#123;// return DruidDataSourceBuilder.create().build();// &#125; /** * 动态数据源配置 */ @Bean @Primary public MultipleDataSource multipleDataSource(@Qualifier(&quot;business&quot;) DruidDataSource db1, @Qualifier(&quot;dw&quot;) DruidDataSource db2, @Qualifier(&quot;seal&quot;) DruidDataSource db3) &#123; MultipleDataSource multipleDataSource = new MultipleDataSource(); Map&lt; Object, Object &gt; targetDataSources = new HashMap&lt;&gt;(); targetDataSources.put(DataSourceEnum.BUSSINESS.getValue(), db1); targetDataSources.put(DataSourceEnum.DW.getValue(), db2); targetDataSources.put(DataSourceEnum.SEAL.getValue(), db3); //添加数据源 multipleDataSource.setTargetDataSources(targetDataSources); //设置默认数据源 multipleDataSource.setDefaultTargetDataSource(db1); return multipleDataSource; &#125; @Bean(&quot;sqlSessionFactory&quot;) public SqlSessionFactory sqlSessionFactory() throws Exception &#123; MybatisSqlSessionFactoryBean sqlSessionFactory = new MybatisSqlSessionFactoryBean(); sqlSessionFactory.setDataSource(multipleDataSource(db1(),db2(),db3())); //sqlSessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(&quot;classpath:/mapper/*/*Mapper.xml&quot;)); MybatisConfiguration configuration = new MybatisConfiguration(); //configuration.setDefaultScriptingLanguage(MybatisXMLLanguageDriver.class); configuration.setJdbcTypeForNull(JdbcType.NULL); configuration.setMapUnderscoreToCamelCase(true); configuration.setCacheEnabled(false); configuration.setLogImpl(StdOutImpl.class); sqlSessionFactory.setConfiguration(configuration); sqlSessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver(). getResources(&quot;classpath*:mapper/*.xml&quot;)); sqlSessionFactory.setConfiguration(configuration); sqlSessionFactory.setPlugins(new Interceptor[]&#123;paginationInterceptor()&#125;); return sqlSessionFactory.getObject(); &#125;&#125; 1234567891011public enum DataSourceEnum &#123; BUSSINESS(&quot;business&quot;),DW(&quot;dw&quot;),SEAL(&quot;seal&quot;),H3(&quot;H3&quot;); private String value; DataSourceEnum(String value)&#123;this.value=value;&#125; public String getValue() &#123; return value; &#125;&#125; 3.使用方式12345678910@Overridepublic int batchUpdateBusinessInfo(ArrayList&lt;BusinessInfoEntity&gt; updateBusinessInfoEntities) &#123; return businessInfoRepo.batchUpdateBusinessInfo(updateBusinessInfoEntities);&#125;@Override@DataSource(DataSourceEnum.DW)public List&lt;BusinessInfoRepoDTO&gt; queryBusinessInfo(BatchBusinessInfoReqDTO reqDTO) &#123; return businessInfoRepo.queryBusinessInfo(reqDTO);&#125;","tags":[{"name":"AOP","slug":"AOP","permalink":"https://zhoufengbin.github.io/tags/AOP/"}]},{"title":"SpringBoot常用注解","date":"2022-03-07T08:09:17.000Z","path":"2022/03/07/SpringBoot常用注解/","text":"时间格式化注解 @DateTimeFormat 和 @JsonFormat @DateTimeFormat：指定入参的时间格式，入参的格式不正确会报错。 12345@Datapublic class DateVo &#123; @DateTimeFormat(pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;) private Date date;&#125; @JsonFormat : 对数据库中查询出的时间类型的数据进行格式化，jackson在序列化时间时是按照国际标准时间GMT进行格式化的，而在国内默认时区使用的是CST时区，两者相差8小时。该注解集成在spring-boot-start-web 下无需再引入依赖。 123456@Datapublic class DateVo &#123; @DateTimeFormat(pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;) @JsonFormat(pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;, timezone=&quot;GMT+8&quot;) private Date date;&#125;","tags":[{"name":"SpringBoot注解","slug":"SpringBoot注解","permalink":"https://zhoufengbin.github.io/tags/SpringBoot%E6%B3%A8%E8%A7%A3/"}]},{"title":"hydee小技术","date":"2022-02-13T12:48:19.000Z","path":"2022/02/13/hydee小技术/","text":"1. 多数据源切换2. 防止表单重复提交3. 误删数据库表或数据的恢复方法。","tags":[{"name":"hydee","slug":"hydee","permalink":"https://zhoufengbin.github.io/tags/hydee/"}]},{"title":"hexo的使用技巧","date":"2022-02-10T10:04:16.000Z","path":"2022/02/10/hexo的使用技巧/","text":"1. 主题1.1 设置或更换主题 下载合适Hexo主题压缩包，将其解压到博客根目录下的themes目录中。 修改 _config.yml 配置文件中theme属性的值为themes中合适的主题文件夹名。 1.2 主题生效或上传Git命令1234-- hexo clean 清除下 Hexo 的缓存-- hexo generate 博客重新生成, 简写 hexo g-- hexo s 本地启动。 http://localhost:4000 可查看(当4000端口被占用可 hexo s -port 选择合适的端口启动。)-- hexo d 部署到git 1.3 创建文件1hexo new &lt;filename&gt;","tags":[{"name":"hexo","slug":"hexo","permalink":"https://zhoufengbin.github.io/tags/hexo/"}]},{"title":"工作BUG","date":"2022-02-10T09:08:03.000Z","path":"2022/02/10/工作BUG/","text":"1. Spring Boot利用K8S部署存在多个实例。 误操作导致的，将本地的配置文件信息上传到了Git上覆盖了分支上的配置文件信息，导致服务启动无法自动替换。","tags":[{"name":"BUG","slug":"BUG","permalink":"https://zhoufengbin.github.io/tags/BUG/"}]},{"title":"MyBaits的使用","date":"2022-01-14T01:11:06.000Z","path":"2022/01/14/MyBaits的使用/","text":"MyBatisMyBatis的模糊查询 方式一 1`field_name` like concat(&#x27;%&#x27;, #&#123;value&#125;, &#x27;%&#x27;) 栗子 1`group_name` like concat(&#x27;%&#x27;,#&#123;groupName&#125;, &#x27;%&#x27;) 方式二 1`field_name` like concat(&#x27;%&#x27;, $&#123;value&#125;, &#x27;%&#x27;) 栗子 1`group_name` like concat(&#x27;%&#x27;,$&#123;groupName&#125;, &#x27;%&#x27;) 总结： #{ }是预编译处理，MyBatis在处理#{ }时，它会将sql中的#{ }替换为？，然后调用PreparedStatement的set方法来赋值，传入字符串后，会在值两边加上单引号，使用占位符的方式提高效率，可以防止sql注入。 ${}:表示拼接sql串，将接收到参数的内容不加任何修饰拼接在sql中，可能引发sql注入。 MyBatis（plus）分页功能 配置类或配置文件中配置分页插件 1234@Beanpublic PaginationInterceptor paginationInterceptor()&#123; return new PaginationIntercpetor();&#125; 创建分页对象，根据不同的构造方法创建合适的分页对象。 1IPage&lt;T&gt; page = new Page&lt;&gt;(); 将page对象作为参数传给待查询方法中，方法返回一个page对象和传入的page对象是同一个。 1IPage&lt;T&gt; queryGroupProgramInfo(IPage&lt;T&gt; page,@Param(&quot;reqDTO&quot;)xxxDTO reqDTO); page对象中常用的方法 方法名称 功能 page.getRecords() 获取分页的数据。 page.getTotal() 数据的总条数 page.getCurrent() 当前页码 page.getPages() 总页数 page.getSize() 每页的条数 MyBatisoe配置信息1234//配置映射文件路径mybatis-plus.mapper-locations=classpath*:mapper/*.xml//打印SQL执行日志信息mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://zhoufengbin.github.io/tags/MyBatis/"}]},{"title":"Java集合之List","date":"2022-01-13T06:58:56.000Z","path":"2022/01/13/Java集合之List/","text":"1、List集合1.1 List集合的排序 内部类方式—Comparator 123456789101112// 升序排序Collections.sort(list, new Comparator&lt;test&gt;() &#123; @Override public int compare(test o1, test o2) &#123; return o1.getCmonth().compareTo(o2.getCmonth()); &#125; // 降序排序Collections.sort(list, new Comparator&lt;test&gt;() &#123; @Override public int compare(test o1, test o2) &#123; return o1.getCmonth().compareTo(o2.getCmonth()); &#125; 实现比较类—Comparable 123456789101112131415161718192021@Datapublic class Test implements Comparable&lt;Test&gt;&#123; private String name; private Integer age; // 升序排序 @Override public int compareTo(Test o) &#123; return this.age.compareTo(o.getAge()); &#125; // 降序排序 @Override public int compareTo(Test o) &#123; return this.age.compareTo(o.getAge()); &#125;&#125;//需要排序的集合排序 List&lt;Test&gt;Collections.sort(list); Stream流方式 1234567// stream流方式-降序排序(逆序排序)list = list.stream().sorted(Comparator.comparing(test::getAge) .reversed()) .collect(Collectors.toList());//stream流方式-升序排序list =list.stream().sorted(Comparator.comparing(test::getAge)) .collect(Collectors.toList());","tags":[{"name":"List","slug":"List","permalink":"https://zhoufengbin.github.io/tags/List/"}]},{"title":"Docker的使用","date":"2022-01-12T08:13:23.000Z","path":"2022/01/12/Docker的使用/","text":"Docker常用命令 功能 命令 启动Docker systemctl start docker 查看全部容器 docker ps -a 查看运行中的容器 docker ps 启动停止的容器 docker start &lt;containerName(container)&gt; 停止容器 docker stop &lt;containerName(containerId)&gt; 删除容器 docker rm $ContainerName(或者$ContainerId) Docker部署MySQL8启动运行MySQL镜像1docker run -p 3306:3306 --name MySQL8.0 -e MYSQL_ROOT_PASSWORD=041225 -d mysql:8.0 进入MySQL12docker exec -it &lt;CONTAINER ID&gt; bashmysql -u root -p 栗子 123[root@izbp116fn1k2l4hhdnx2iyz ~]# docker exec -it 88c99b8037f9 bashroot@88c99b8037f9:/# mysql -u root -pEnter password: 处理SQLYog无法连接MySQL8 进入MySQL容器 执行命令 1ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;password&#x27;; 12ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;041225&#x27;;FLUSH PRIVILEGES; 重启MySQL镜像1docker restart &lt;CONTAINER ID&gt;","tags":[{"name":"Docker","slug":"Docker","permalink":"https://zhoufengbin.github.io/tags/Docker/"}]},{"title":"MySQL数据库基础","date":"2022-01-12T07:04:53.000Z","path":"2022/01/12/MySQL数据库常用SQL操作/","text":"1. MySQL基础1.0MySQL的数据类型unsigned 无符号 数值类型 类型 大小 范围（有符号） 范围（无符号） 用途 tinyint 1byte (-128, 127) (0, 255) 小整数值 smallint 2byte (-32768, 32767) (0, 65535) 大整数值 mediumint 3btye (-8388608, 8388607) (0, 16777215) 大整数值 int 4byte (-2147483648, 2147483647) (0, 4294967295) 大整数值 bigint 8byte 极大整数值 float 4byte double 8byte decimal 依赖M和D的值 小数值 如：decimal(5,2) 123.45 字符串类型 日期时间类型 类型 大小(byte) 范围 格式 用途 date 3 1000-01-01~9999-12-31 YYYY-MM-DD 日期值 time 3 -838:59:59~838:59:59 HH:MM:SS 时间值 year 1 1901~2155 YYYY 年份值 datetime 8 1000-01-01 00:00:00 ~9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS timestamp 4 1970-01-01 00:00:01 UTC ~2038-01-19 03:14:07 UTC YYYY-MM-DD HH:MM:SS 注意：与时区关系. datetime是存储服务器当前的时区. 而timestamp类型,是将服务器当前时间转换为UTC(世界时间)来存储.即datetime与时区无关,存什么,返回什么. 而timestamp存储的时间,返回的时间会随着数据库的时区不同而发生改变. 1.1 MySQL数据库基本操作-DDL DDL(Data Definition Langauage),数据定义语言，该部分语言包含一些部分： 对数据库的常用操作。 对表结构的常用操作。 对数据库的常用操作 功能 SQL 查看所有的数据库 show databases; 创建数据库 create database [if not exists] [charset=utf8] 切换数据库 user 删除数据库 drop database [if exists] 修改数据库编码 alter database character set utf8 对表结构的常用操作 功能 SQL 查看当前数据库中的所有表名称 show tables; 查看指定某个表的创建语句 show create table ; 查看表结构 desc ; 删除表 drop table ; 创建表 123456create table [if not exists] &lt;tablename&gt;( 字段1 数据类型[(长度)] [约束条件] [定义字段字符集] [comment &#x27;字段说明&#x27;], 字段2 数据类型[(长度)] [约束条件] [定义字段字符集] [comment &#x27;字段说明&#x27;], 字段3 数据类型[(长度)] [约束条件] [定义字段字符集] [comment &#x27;字段说明&#x27;], ......)ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT=&#x27;表名&#x27;; 1234567891011121314151617181920212223242526272829303132CREATE TABLE `order_info` ( `id` bigint NOT NULL AUTO_INCREMENT COMMENT &#x27;编号&#x27;, `user_id` bigint DEFAULT NULL, `out_trade_no` varchar(300) DEFAULT NULL COMMENT &#x27;订单交易号&#x27;, `hoscode` varchar(30) DEFAULT NULL COMMENT &#x27;医院编号&#x27;, `hospital_name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT &#x27;医院名称&#x27;, `depcode` varchar(30) DEFAULT NULL COMMENT &#x27;科室编号&#x27;, `depname` varchar(20) DEFAULT NULL COMMENT &#x27;科室名称&#x27;, `title` varchar(20) DEFAULT NULL COMMENT &#x27;医生职称&#x27;, `hos_schedule_id` varchar(50) DEFAULT NULL COMMENT &#x27;排班编号（医院自己的排班主键）&#x27;, `reserve_date` date DEFAULT NULL COMMENT &#x27;安排日期&#x27;, `reserve_time` tinyint DEFAULT &#x27;0&#x27; COMMENT &#x27;安排时间（0：上午 1：下午）&#x27;, `patient_id` bigint DEFAULT NULL COMMENT &#x27;就诊人id&#x27;, `patient_name` varchar(20) DEFAULT NULL COMMENT &#x27;就诊人名称&#x27;, `patient_phone` varchar(11) DEFAULT NULL COMMENT &#x27;就诊人手机&#x27;, `hos_record_id` varchar(30) DEFAULT NULL COMMENT &#x27;预约记录唯一标识（医院预约记录主键）&#x27;, `number` int DEFAULT NULL COMMENT &#x27;预约号序&#x27;, `fetch_time` varchar(50) DEFAULT NULL COMMENT &#x27;建议取号时间&#x27;, `fetch_address` varchar(255) DEFAULT NULL COMMENT &#x27;取号地点&#x27;, `amount` decimal(10,0) DEFAULT NULL COMMENT &#x27;医事服务费&#x27;, `quit_time` datetime DEFAULT NULL COMMENT &#x27;退号时间&#x27;, `order_status` tinyint DEFAULT NULL COMMENT &#x27;订单状态&#x27;, `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;, `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;更新时间&#x27;, `is_delete` tinyint DEFAULT &#x27;1&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `uk_out_trade_no` (`out_trade_no`), KEY `idx_user_id` (`user_id`), KEY `idx_hoscode` (`hoscode`), KEY `idx_hos_schedule_id` (`hos_schedule_id`), KEY `idx_hos_record_id` (`hos_record_id`)) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8mb3 COMMENT=&#x27;订单表&#x27; 修改表结构 添加表字段,添加到指定字段的后面。 1alter table &lt;tablename&gt; add &lt;filedname&gt; 类型(长度) [约束] [after &lt;已存在的字段&gt;]; 修改表字段名称 1alter table &lt;tablename&gt; rename column &lt;filedname&gt; to &lt;newfiledname&gt; 修改表字段属性 1alter table &lt;tablename&gt; modify &lt;filedname&gt; 类型(长度) [其他属性] 删除表字段 1alter table &lt;tablename&gt; drop column &lt;filedname&gt;; 12345678-- 添加表字段alter table order_info add `is_delete` tinyint default 1 after update_time;-- 修改表字段名称alter table order_info rename column `hosname` to `hospital_name`;-- 修改表字段属性alter table order_info modify hospital_name varchar(100) character set utf8mb4 collate utf8mb4_general_ci default null comment &#x27;医院名称&#x27;;-- 删除表字段alter table order_info drop column is_deleted; 一、基本SQL1. 查看MySQL数据库版本1SELECT VERSION(); 2. 常见关键字 CURRENT_TIMESTAMP DEFAULT CURRENT_TIMESTAMP 表示当插入数据的时候，该字段默认值为当前时间 ON UPDATE CURRENT_TIMESTAMP 表示每次更新这条数据的时候，该字段都会更新成当前时间 栗子 12345CREATE TABLE `test` ( `text` varchar(255) DEFAULT &#x27;&#x27; COMMENT &#x27;内容&#x27;, `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;, `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;更新时间&#x27;) ENGINE=InnoDB DEFAULT CHARSET=utf8; 3. 常用函数 日期函数 YEAR(date) 获取date类型数据的年 MONTH(date) 获取date类型数据的月 DAY(date) 获取date类型数据的日 CONCAT() 字符串拼接函数 concat(col_1, col_2, …) 栗子1：concat函数中无null 1SELECT region_id, region_name, CONCAT(region_id, &#x27;-&#x27;, region_name) AS a FROM regions; 结果集： 123456region_id region_name a --------- ---------------------- -------------------------- 1 Europe 1-Europe 2 Americas 2-Americas 3 Asia 3-Asia 4 Middle East and Africa 4-Middle East and Africa 栗子1：concat函数中有null 1SELECT region_id, region_name, CONCAT(region_id, null, region_name) AS a FROM regions; 结果集 123456region_id region_name a --------- ---------------------- -------- 1 Europe (NULL) 2 Americas (NULL) 3 Asia (NULL) 4 Middle East and Africa (NULL) 3. SQL 创建/修改唯一索引 创建 1UNIQUE [INDEX | KEY] [&lt;索引名&gt;] [&lt;索引类型&gt;] (&lt;列名&gt;,…) 栗子 1UNIQUE KEY `unique_index`(`group_id`, `company_id`, `business_id`) 注意事项：在创建唯一索引时，一定要保证索引的唯一性。如上面栗子的索引字段，保存数据时是重复的，此时索引创建会报错。 修改 12ALTER TABLE `TableName` DROP INDEX `INDEX_NAME`;ALTER TABLE `TableName` ADD UNIQUE INDEX_NAME(`COLUMN`); 栗子 12ALTER TABLE follow_heart_store_sales_target_collect DROP INDEX `unique_index`ALTER TABLE follow_heart_store_sales_target_collect ADD UNIQUE KEY `unique_index`(`cdate`,`group_id`, `company_id`, `business_id`) 注意：修改索引实际上是删除旧索引后，重新创建合适的索引。 二、CTE(公共表表达式)1. 什么是公用表表达式或CTE？ 公用表表达式是一个命名的临时结果集(临时表)，仅在单个SQL语句(例如SELECT，INSERT，UPDATE或DELETE)的执行范围内存在。 CTE不作为对象存储，仅在查询执行期间持续。 CTE可以是自引用(递归CTE)，也可以在同一查询中多次引用。 与派生表相比，CTE提供了更好的可读性和性能。 2. CTE语法 CTE主要构成： 临时表名，展示临时表列 (不写默认展示所有)，定义CTE的查询 (单个SQL语句)。 123456789WITH cte_name1[(column_list)] AS ( //单个SQL语句(一般都是查询操作)),cte_name2 AS[(column_list)] ( //单个SQL语句),...SELECT column_name1,[column_name2,...]FROM cte_name1,cte_name2; 三、MySQL8.0 窗口函数3.1 什么是窗口函数？ 窗口函数在MySQL8+才支持的函数，又称分析函数。 窗口函数 = 窗口 + 函数。 窗口的大小可以是固定的，也可以是可变的，还可以是滑动的。 窗口函数可以在查询出来的结果集(该结果集肯定满足某些条件)上，设置一个窗口，为窗口内的每条数据都执行一次窗口函数。 一般窗口函数对应的列，会紧跟结果集的后面。 3.2 窗口函数语法1windows_function([expression]) over([partition by &lt;分区的列&gt;] [order by &lt;排序的列&gt;] [rows between &lt;范围&gt;]) over中参数可省略。如果为空，则窗口的大小是满足where条件的所有数据大小。 rows betweet的实例 123456789rows between 2 preceding and current row -- 取当前行和前面两行。rows between unbounded preceding and current row -- 取当前行和前面所有行。rows between current row and unbounded following -- 取当前行和后面所有行。rows between 3 preceding and current row -- 取当前行和前三行。rows between 3 precding and 1 following -- 取当前行和前三行和后一行，共5行。 当省略 rows bteween ,则默认为 rows between unbounded preceding and current row。 当省略 order by 和 rows between , 则默认为 rows between unbounded preceding and unbounded following 3.3 窗口函数分类 排名窗口函数 rank dense_rank percent_rank row_number4 ntile cume_dist 取值窗口函数 lag lead first_value last_value nth_value 聚合窗口函数 ave sum count max min SQL 窗口函数速查表_Tony.Dong的专栏-CSDN博客 3.4 窗口函数应用 附录1： windows命令行操作数据库1. 命令行启动停止MySQL123net start/stop &lt;服务名称&gt;启动: net start mysql80停止: net stop mysql80 2.进入MySQL1mysql -u root -p -h localhost [-P 3308]","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://zhoufengbin.github.io/tags/MySQL/"}]},{"title":"多线程","date":"2022-01-01T03:59:31.000Z","path":"2022/01/01/多线程/","text":"1. 多线程简介","tags":[{"name":"多线程","slug":"多线程","permalink":"https://zhoufengbin.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"Java常用API","date":"2021-12-31T16:08:39.000Z","path":"2022/01/01/Java常用API/","text":"1. String常用方法1.1 截取功能1","tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://zhoufengbin.github.io/tags/Java%E5%9F%BA%E7%A1%80/"}]}]